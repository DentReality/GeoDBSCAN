{"version":3,"file":"geodbscan.cjs","sources":["../src/geodbscan.ts"],"sourcesContent":["export default class GeoDBSCAN {\n  private _dataset: [number, number][];\n  private _epsilon: number;\n  private _minPts: number;\n  private _clusters: number[][];\n  private _noise: number[];\n  private _visited: number[];\n  private _assigned: number[];\n  private _datasetLength = 0;\n\n  constructor() {\n    this._dataset = [];\n    this._epsilon = 1;\n    this._minPts = 2;\n    this._clusters = [];\n    this._noise = [];\n    this._visited = [];\n    this._assigned = [];\n    this._datasetLength = 0;\n  }\n\n  public cluster(\n    dataset: [number, number][],\n    options: {\n      minPts: number;\n      epsilon?: number;\n    }\n  ) {\n    if (dataset) {\n      if (!(dataset instanceof Array)) {\n        throw Error(\n          \"Dataset must be of type array, \" + typeof dataset + \" given\"\n        );\n      }\n\n      this._dataset = dataset;\n      this._clusters = [];\n      this._noise = [];\n\n      this._datasetLength = dataset.length;\n      this._visited = new Array(this._datasetLength);\n      this._assigned = new Array(this._datasetLength);\n    }\n\n    if (options.minPts && typeof options.minPts === \"number\") {\n      this._minPts = options.minPts;\n    } else {\n      throw Error(\n        \"Minimum points must be defined and of type number (integer)\"\n      );\n    }\n\n    // Epsilon is optional as we can try to determine\n    // a sensible value automatically\n    if (options.epsilon) {\n      this._epsilon = options.epsilon;\n    } else {\n      this._epsilon = this._getkNNDistPlotKnee(dataset, this._minPts);\n    }\n\n    for (let pointId = 0; pointId < this._datasetLength; pointId++) {\n      // If point is not visited, check if it forms a cluster\n      if (this._visited[pointId] !== 1) {\n        this._visited[pointId] = 1;\n\n        // If closest neighborhood is too small to form a cluster, mark as noise\n        const neighbors = this._regionQuery(pointId);\n\n        if (neighbors.length < this._minPts) {\n          this._noise.push(pointId);\n        } else {\n          // Create new cluster and add point\n          const clusterId = this._clusters.length;\n          this._clusters.push([]);\n          this._addToCluster(pointId, clusterId);\n\n          this._expandCluster(clusterId, neighbors);\n        }\n      }\n    }\n\n    return this._clusters;\n  }\n\n  private _kNNDistPlot(dataset: [number, number][], k: number) {\n    // We can estimate a good epsilon value by determing\n    // an ordered list of all the k-th nearest distances\n    // from each point\n    const kDistances = [];\n\n    dataset.forEach((datapoint, i) => {\n      const distances = [];\n      dataset.forEach((datapointTwo, j) => {\n        if (i !== j) {\n          distances.push(\n            this._haversineDistanceMeters(datapoint, datapointTwo)\n          );\n        }\n      });\n      // Ascending order\n      distances.sort((a, b) => a - b);\n      kDistances.push(distances[k - 1]);\n    });\n\n    kDistances.sort((a, b) => b - a);\n    return kDistances;\n  }\n\n  private _getkNNDistPlotKnee(dataset: [number, number][], k: number) {\n    const kDistances = this._kNNDistPlot(dataset, k);\n\n    let biggestDiff = -Infinity;\n    let biggestDiffIndex;\n\n    console.log(kDistances);\n\n    if (dataset.length < 3) {\n      throw new Error(\"Requires at least 3 data points to determine epsilon\");\n    }\n\n    if (dataset.length === 3) {\n      return kDistances[1];\n    }\n\n    let total = 0;\n    for (let i = 0; i < kDistances.length - 1; i++) {\n      const distance = kDistances[i];\n      const nextDistance = kDistances[i + 1];\n      const diff = distance - nextDistance;\n      total += diff;\n    }\n\n    const meanDelta = total / kDistances.length - 1;\n\n    const aboveMeanDelta = [];\n\n    for (let i = 0; i < kDistances.length - 1; i++) {\n      const distance = kDistances[i];\n      const nextDistance = kDistances[i + 1];\n      const diff = distance - nextDistance;\n\n      if (diff > meanDelta) {\n        aboveMeanDelta.push(true);\n      } else {\n        aboveMeanDelta.push(false);\n      }\n    }\n\n    let knee = Math.round(kDistances.length / 2);\n\n    let confidence = aboveMeanDelta.length;\n    for (let i = 0; i < aboveMeanDelta.length - 1; i++) {\n      if (!aboveMeanDelta[i]) {\n        confidence--;\n      }\n\n      if (confidence / aboveMeanDelta.length < 3 / 4) {\n        knee = i;\n        break;\n      }\n    }\n\n    console.log(JSON.stringify(knee));\n    return kDistances[knee];\n  }\n\n  private _mergeArrays(a: number[], b: number[]) {\n    const len = b.length;\n\n    for (let i = 0; i < len; i++) {\n      const P = b[i];\n      if (a.indexOf(P) < 0) {\n        a.push(P);\n      }\n    }\n\n    return a;\n  }\n\n  private _haversineDistanceMeters(\n    pointOne: [number, number],\n    pointTwo: [number, number]\n  ) {\n    const toRadians = (latOrLng: number) => (latOrLng * Math.PI) / 180;\n\n    const phiOne = toRadians(pointOne[1]);\n    const lambdaOne = toRadians(pointOne[0]);\n    const phiTwo = toRadians(pointTwo[1]);\n    const lambdaTwo = toRadians(pointTwo[0]);\n    const deltaPhi = phiTwo - phiOne;\n    const deltalambda = lambdaTwo - lambdaOne;\n\n    const a =\n      Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +\n      Math.cos(phiOne) *\n        Math.cos(phiTwo) *\n        Math.sin(deltalambda / 2) *\n        Math.sin(deltalambda / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    const radius = 6371e3;\n    const distance = radius * c;\n\n    return distance;\n  }\n\n  private _regionQuery(pointId: number) {\n    const neighbors: number[] = [];\n\n    for (let id = 0; id < this._datasetLength; id++) {\n      const dist = this._haversineDistanceMeters(\n        this._dataset[pointId],\n        this._dataset[id]\n      );\n      if (dist < this._epsilon) {\n        neighbors.push(id);\n      }\n    }\n\n    return neighbors;\n  }\n\n  private _expandCluster(clusterId: number, neighbors: number[]) {\n    // It's very important to calculate length of neighbors array each time,\n    // as the number of elements changes over time\n    for (let i = 0; i < neighbors.length; i++) {\n      const pointId2 = neighbors[i];\n      if (this._visited[pointId2] !== 1) {\n        this._visited[pointId2] = 1;\n        const neighborsTwo = this._regionQuery(pointId2);\n\n        if (neighborsTwo.length >= this._minPts) {\n          neighbors = this._mergeArrays(neighbors, neighborsTwo);\n        }\n      }\n\n      // Add to cluster\n      if (this._assigned[pointId2] !== 1) {\n        this._addToCluster(pointId2, clusterId);\n      }\n    }\n  }\n\n  private _addToCluster(pointId: number, clusterId: number) {\n    this._clusters[clusterId].push(pointId);\n    this._assigned[pointId] = 1;\n  }\n}\n"],"names":["_dataset","_epsilon","_minPts","_clusters","_noise","_visited","_assigned","_datasetLength","this","cluster","dataset","options","Array","Error","length","minPts","epsilon","_getkNNDistPlotKnee","pointId","neighbors","_regionQuery","push","clusterId","_addToCluster","_expandCluster","_kNNDistPlot","k","kDistances","forEach","datapoint","i","distances","datapointTwo","j","_this","_haversineDistanceMeters","sort","a","b","console","log","total","meanDelta","aboveMeanDelta","knee","Math","round","confidence","JSON","stringify","_mergeArrays","len","P","indexOf","pointOne","pointTwo","toRadians","latOrLng","PI","phiOne","lambdaOne","phiTwo","deltaPhi","deltalambda","sin","cos","atan2","sqrt","id","pointId2","neighborsTwo"],"mappings":"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"}