{"version":3,"file":"geodbscan.modern.js","sources":["../src/geodbscan.ts"],"sourcesContent":["export default class GeoDBSCAN {\n  private _dataset: [number, number][];\n  private _epsilon: number;\n  private _minPts: number;\n  private _clusters: number[][];\n  private _noise: number[];\n  private _visited: number[];\n  private _assigned: number[];\n  private _datasetLength = 0;\n\n  constructor() {\n    this._dataset = [];\n    this._epsilon = 1;\n    this._minPts = 2;\n    this._clusters = [];\n    this._noise = [];\n    this._visited = [];\n    this._assigned = [];\n    this._datasetLength = 0;\n  }\n\n  public cluster(\n    dataset: [number, number][],\n    options: {\n      minPts: number;\n      epsilon?: number;\n    }\n  ) {\n    if (dataset) {\n      if (!(dataset instanceof Array)) {\n        throw Error(\n          \"Dataset must be of type array, \" + typeof dataset + \" given\"\n        );\n      }\n\n      this._dataset = dataset;\n      this._clusters = [];\n      this._noise = [];\n\n      this._datasetLength = dataset.length;\n      this._visited = new Array(this._datasetLength);\n      this._assigned = new Array(this._datasetLength);\n    }\n\n    if (options.minPts && typeof options.minPts === \"number\") {\n      this._minPts = options.minPts;\n    } else {\n      throw Error(\n        \"Minimum points must be defined and of type number (integer)\"\n      );\n    }\n\n    // Epsilon is optional as we can try to determine\n    // a sensible value automatically\n    if (options.epsilon) {\n      this._epsilon = options.epsilon;\n    } else {\n      this._epsilon = this._getkNNDistPlotKnee(dataset, this._minPts);\n    }\n\n    for (let pointId = 0; pointId < this._datasetLength; pointId++) {\n      // If point is not visited, check if it forms a cluster\n      if (this._visited[pointId] !== 1) {\n        this._visited[pointId] = 1;\n\n        // If closest neighborhood is too small to form a cluster, mark as noise\n        const neighbors = this._regionQuery(pointId);\n\n        if (neighbors.length < this._minPts) {\n          this._noise.push(pointId);\n        } else {\n          // Create new cluster and add point\n          const clusterId = this._clusters.length;\n          this._clusters.push([]);\n          this._addToCluster(pointId, clusterId);\n\n          this._expandCluster(clusterId, neighbors);\n        }\n      }\n    }\n\n    return this._clusters;\n  }\n\n  private _kNNDistPlot(dataset: [number, number][], k: number) {\n    // We can estimate a good epsilon value by determing\n    // an ordered list of all the k-th nearest distances\n    // from each point\n    const kDistances = [];\n\n    dataset.forEach((datapoint, i) => {\n      const distances = [];\n      dataset.forEach((datapointTwo, j) => {\n        if (i !== j) {\n          distances.push(\n            this._haversineDistanceMeters(datapoint, datapointTwo)\n          );\n        }\n      });\n      // Ascending order\n      distances.sort((a, b) => a - b);\n      kDistances.push(distances[k - 1]);\n    });\n\n    kDistances.sort((a, b) => b - a);\n    return kDistances;\n  }\n\n  private _getkNNDistPlotKnee(dataset: [number, number][], k: number) {\n    const kDistances = this._kNNDistPlot(dataset, k);\n\n    let biggestDiff = -Infinity;\n    let biggestDiffIndex;\n\n    console.log(kDistances);\n\n    if (dataset.length < 3) {\n      throw new Error(\"Requires at least 3 data points to determine epsilon\");\n    }\n\n    if (dataset.length === 3) {\n      return kDistances[1];\n    }\n\n    let total = 0;\n    for (let i = 0; i < kDistances.length - 1; i++) {\n      const distance = kDistances[i];\n      const nextDistance = kDistances[i + 1];\n      const diff = distance - nextDistance;\n      total += diff;\n    }\n\n    const meanDelta = total / kDistances.length - 1;\n\n    const aboveMeanDelta = [];\n\n    for (let i = 0; i < kDistances.length - 1; i++) {\n      const distance = kDistances[i];\n      const nextDistance = kDistances[i + 1];\n      const diff = distance - nextDistance;\n\n      if (diff > meanDelta) {\n        aboveMeanDelta.push(true);\n      } else {\n        aboveMeanDelta.push(false);\n      }\n    }\n\n    let knee = Math.round(kDistances.length / 2);\n\n    let confidence = aboveMeanDelta.length;\n    for (let i = 0; i < aboveMeanDelta.length - 1; i++) {\n      if (!aboveMeanDelta[i]) {\n        confidence--;\n      }\n\n      if (confidence / aboveMeanDelta.length < 3 / 4) {\n        knee = i;\n        break;\n      }\n    }\n\n    console.log(JSON.stringify(knee));\n    return kDistances[knee];\n  }\n\n  private _mergeArrays(a: number[], b: number[]) {\n    const len = b.length;\n\n    for (let i = 0; i < len; i++) {\n      const P = b[i];\n      if (a.indexOf(P) < 0) {\n        a.push(P);\n      }\n    }\n\n    return a;\n  }\n\n  private _haversineDistanceMeters(\n    pointOne: [number, number],\n    pointTwo: [number, number]\n  ) {\n    const toRadians = (latOrLng: number) => (latOrLng * Math.PI) / 180;\n\n    const phiOne = toRadians(pointOne[1]);\n    const lambdaOne = toRadians(pointOne[0]);\n    const phiTwo = toRadians(pointTwo[1]);\n    const lambdaTwo = toRadians(pointTwo[0]);\n    const deltaPhi = phiTwo - phiOne;\n    const deltalambda = lambdaTwo - lambdaOne;\n\n    const a =\n      Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +\n      Math.cos(phiOne) *\n        Math.cos(phiTwo) *\n        Math.sin(deltalambda / 2) *\n        Math.sin(deltalambda / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    const radius = 6371e3;\n    const distance = radius * c;\n\n    return distance;\n  }\n\n  private _regionQuery(pointId: number) {\n    const neighbors: number[] = [];\n\n    for (let id = 0; id < this._datasetLength; id++) {\n      const dist = this._haversineDistanceMeters(\n        this._dataset[pointId],\n        this._dataset[id]\n      );\n      if (dist < this._epsilon) {\n        neighbors.push(id);\n      }\n    }\n\n    return neighbors;\n  }\n\n  private _expandCluster(clusterId: number, neighbors: number[]) {\n    // It's very important to calculate length of neighbors array each time,\n    // as the number of elements changes over time\n    for (let i = 0; i < neighbors.length; i++) {\n      const pointId2 = neighbors[i];\n      if (this._visited[pointId2] !== 1) {\n        this._visited[pointId2] = 1;\n        const neighborsTwo = this._regionQuery(pointId2);\n\n        if (neighborsTwo.length >= this._minPts) {\n          neighbors = this._mergeArrays(neighbors, neighborsTwo);\n        }\n      }\n\n      // Add to cluster\n      if (this._assigned[pointId2] !== 1) {\n        this._addToCluster(pointId2, clusterId);\n      }\n    }\n  }\n\n  private _addToCluster(pointId: number, clusterId: number) {\n    this._clusters[clusterId].push(pointId);\n    this._assigned[pointId] = 1;\n  }\n}\n"],"names":["constructor","_dataset","_epsilon","_minPts","_clusters","_noise","_visited","_assigned","_datasetLength","this","cluster","dataset","options","Array","Error","length","minPts","epsilon","_getkNNDistPlotKnee","pointId","neighbors","_regionQuery","push","clusterId","_addToCluster","_expandCluster","_kNNDistPlot","k","kDistances","forEach","datapoint","i","distances","datapointTwo","j","_haversineDistanceMeters","sort","a","b","console","log","total","meanDelta","aboveMeanDelta","knee","Math","round","confidence","JSON","stringify","_mergeArrays","len","P","indexOf","pointOne","pointTwo","toRadians","latOrLng","PI","phiOne","lambdaOne","phiTwo","deltaPhi","deltalambda","sin","cos","atan2","sqrt","id","pointId2","neighborsTwo"],"mappings":"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"}